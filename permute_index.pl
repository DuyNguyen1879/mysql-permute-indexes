#!/usr/bin/perl

# Program: permute_index.pl
# Purpose: generate all permutations of index statements of up to 3 columns per table for complex queries
# Author: James Briggs
# Date: 2014 11 19
# Version: 0.2
# Env: perl5
# Example:
# $ permute_indexes.pl | tee permute_indexes.txt
#    alter table t1 add index idx_jb_001 (c1,c3);
#    alter table t1 add index idx_jb_002 (c1,c2,c3);
#    alter table t1 add index idx_jb_003 (c1,c3,c2);
#    [...]
#    alter table t2 add index idx_jb_007 (c4,c5);
#    [...]
# $ mysql -u root -p test <permute_indexes.txt
# mysql> explain select * from t1, t2 where c1=c4 and c1=? and c2=? and c3=? and c5=?;
# Table | Key
# --------------
# t1 | idx_jb_002
# t2 | idx_jb_007
#
# Notes: "There are no provisions for indexes in the SQL standard."

use strict;
use diagnostics;

   my $dt = fmt_dt();

###
### Start of user settings
###

   # list all tables used in the query with all of the columns per table from
   #  the join, WHERE, GROUP, ORDER and LIMIT clauses you want to permute indexes for
   my %tables = (
      t1 => [ ('c1', 'c2', 'c3', 'c3(10) desc', 'c3(10) asc', ) ],
      t2 => [ ('c4', 'c5', 'c6', ) ],
   );

   # list tables with all pre-existing index column names here to not duplicate.
   # (for multi-column indexes, comma-separate column names)
   my %old_indexes = (
      t1 => [ ('c1', 'c1,c2',) ],
      t2 => [ ('c4',) ],
   );

   my %options = (
      db     => 'mysql', # mysql, oracle, pg, sqlserver
      online => 0,       # 1=online, 0=offline
      extra  => '',      # eg. 'TABLESPACE users STORAGE (INITIAL 20K NEXT 20k PCTINCREASE 75) INVISIBLE'
   );

###
### End of user settings
###

   my $comment = 'Autogenerated by permute_indexes.pl ' . $dt;
   my $db = $options{db};

   my %seen_global;

   for my $t (sort keys %old_indexes) {
      for my $c (@{$old_indexes{$t}}) {
         $c =~ s/ +//g;
         $seen_global{$c} = 1 if defined $c;
      }
   }

   my $n=1;

   print "-- $dt Start\n";

   for my $t (sort keys %tables) {
      my $r=$tables{$t};
      push @{$r}, undef;
      for my $c1 (@{$r}) {
         for my $c2 (@{$r}) {
             for my $c3 (@{$r}) {
                my %seen_local;
                my @cols;

                for my $c (($c1, $c2, $c3)) {
                   next if not defined $c or $c eq '';
                   my $col_name = $c;
                   $col_name =~ s/[(].*$//; # to avoid repeating column names, strip off possible index prefix length, as in col(10)
                   if (not exists $seen_local{$col_name}) {
                      push @cols, $c;
                      $seen_local{$col_name} = 1;
                    }
                }
   
                my $idx_col_names = join(', ', @cols);
                next if $idx_col_names eq '' or $seen_global{$idx_col_names}++;
   
                my $sql = '';

                if ($db eq 'mysql') {
                   $sql = sprintf("create index idx_jb_%03d on $t ($idx_col_names) %s@{[ $options{online} ? 'algorithm=inplace ' : '' ]}", $n++, $options{extra});
                }
                elsif ($db eq 'oracle') {
                   $sql = sprintf("create index idx_jb_%03d on $t ($idx_col_names) @{[ $options{online} ? 'online ' : '' ]}%s", $n++, $options{extra});
                 }
                elsif ($db eq 'pg') {
                   $sql = sprintf("create index @{[ $options{online} ? 'concurrently ' : '' ]}idx_jb_%03d on $t ($idx_col_names) %s", $n++, $options{extra});
                }
                elsif ($db eq 'sqlserver') {
                   $sql = sprintf("create index idx_jb_%03d on $t ($idx_col_names) %s", $n++, $options{extra});
                }
                else {
                    die "error: bad database.";
                }

                chop $sql if substr($sql, -1) eq ' ';
                print "$sql;\n";
             }
         }
      }
   }

   $n--;
   $dt = fmt_dt();
   print "-- $dt End ($n statements)\n";

   exit;

sub fmt_dt {
   my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime;

   my $dt = sprintf("%04d-%02d-%02d %02d:%02d:%02d", $year+1900, $mon++, $mday, $hour, $min, $sec);

   return $dt;
}

